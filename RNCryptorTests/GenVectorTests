#!/usr/bin/env ruby

require 'optparse'

class String
  def unindent 
    gsub(/^#{scan(/^\s*/).min_by{|l|l.length}}/, "")
  end
end

def getUncommentedLinesFromPath(path)
  File.readlines(path)
  .select{ |line| line !~ /^#/ }
  .map { |line| line.sub(/^\s#.*/, "").chomp }
end

def getBlocksFromLines(lines)
  blocks = []
  block = []
  lines.each do |line|
    if line.length == 0
      if block.length > 0
        blocks << block
        block = []
      end
      next
    end

    block << line
  end

  if block.length > 0
    blocks << block
  end

  return blocks

  # "chunk" doesn't seem available on older ruby?
  # lines.chunk { |l| (l =~ /^\s*$/) == nil }
  # .map { |not_blank, a| a if not_blank }
  # .compact
end

def mapBlocksToVectors(blocks)
  blocks.map { |block|
    Hash[*
      block.map { |l| l.split(/\s*:\s*/, 2) }
      .flatten
    ]
  }
end

def getVectorsFromPath(path)
  mapBlocksToVectors getBlocksFromLines getUncommentedLinesFromPath path
end

def dictionaryForHash(hash)
  "@{\n" + hash.collect { |key, value| %Q(    @"#{key}": @"#{value}") }.join(",\n") + "}"
end

options = {}

opt_parser = OptionParser.new do |opt|
  opt.banner = "Usage: GenVectorTest -o VectorTests.m -3 v3_directory"
  opt.separator  ""
  opt.on("-o","--output PATH","path to output code") do |output_path|
    options[:output_path] = output_path
  end
  opt.on("-3", "-3 PATH", "path to v3 directory") do |v3_directory|
    options[:v3_directory] = v3_directory
  end
end

opt_parser.parse!

raise OptionParser::MissingArgument if options[:output_path].nil?
raise OptionParser::MissingArgument if options[:v3_directory].nil?

File.open(options[:output_path], "w") do |output|
  output << <<-HEADER
// Automatically Generated by GenVectorTests
#import "RNCryptorVectorTests.h"
@interface RNCryptorGeneratedVectorTests : RNCryptorVectorTests
@end
@implementation RNCryptorGeneratedVectorTests
HEADER

  getVectorsFromPath(options[:v3_directory] + "/kdf").each do |vector|
    output << <<-TEST_CASE

- (void)test_kdf_#{vector["title"].gsub(' ', '_')} {
  [self verifyKDFVector:#{dictionaryForHash(vector)}];
}

TEST_CASE

  end

  output<< <<-FOOTER
@end
FOOTER

end
